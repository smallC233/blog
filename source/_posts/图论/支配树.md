---
title: 支配树
categories:
  - [竞赛相关, 图论]
  - [竞赛相关, 数据结构]
---
本文来源：[康复计划#4 快速构造支配树的Lengauer-Tarjan算法 - MoebiusMeow - 博客园](https://www.cnblogs.com/meowww/p/6475952.html)

# 快速构造支配树的 Lengauer-Tarjan 算法

　　本篇口胡写给我自己这样的老是证错东西的口胡选手 以及那些想学支配树，又不想啃论文原文的人…

　　大概会讲的东西是求支配树时需要用到的一些性质，以及构造支配树的算法实现…

　　最后讲一下把只有路径压缩的并查集卡到$O(m \log n)$上界的办法作为小彩蛋…

 

## 支配树基本介绍

​	支配树（Dominator Tree）。

　　对于一个流程图（单源有向图）上的每个点$w$，都存在点$d$满足去掉$d$之后起点无法到达$w$，我们称作$d$支配$w$，$d$是$w$的一个支配点。

　　![img](https://images2015.cnblogs.com/blog/842061/201702/842061-20170227130718438-828873306.png)

　　支配$w$的点可以有多个，但是至少会有一个。显然，对于起点以外的点，它们都有两个平凡的支配点，一个是自己，一个是起点。

　　在支配$w$的点中，如果一个支配点$i \neq w$满足$i$被$w$剩下的所有非平凡支配点支配，则这个$i$称作$w$的最近支配点(immediate dominator)，记作$idom(w)$。

### 定理1

​	我们把图的起点称作 $r$，除 $r$ 以外每个点均存在唯一的 $idom$。

　　这个的证明很简单：如果$a$支配$b$且$b$支配$c$，则$a$一定支配$c$，因为到达$c$的路径都经过了$b$所以必须经过$a$；如果$b$支配$c$且$a$支配$c$，则$a$支配$b$（或者$b$支配$a$），否则存在从$r$到$b$再到$c$的路径绕过$a$，与$a$支配$c$矛盾。这就意味着支配定义了点$w$的支配点集合上的一个全序关系，所以一定可以找到一个“最小”的元素使得所有元素都支配它。

　　于是，连上所有$r$以外的$idom(w) \to w$的边，就能得到一棵树，其中每个点支配它子树中的所有点，它就是支配树。

　　![img](https://images2015.cnblogs.com/blog/842061/201702/842061-20170227132658720-1476160876.png)

　　支配树有很多食用…哦不…是实际用途。比如它展示了一个信息传递网络的关键点，如果一个点支配了很多点，那么这个点的传递效率和稳定性要求都会很高。比如Java的内存分析工具(Memory Analyzer Tool)里面就可以查看对象间引用关系的支配树…很多分析上支配树都是一个重要的参考。

　　为了能够求出支配树，我们下面来介绍一下需要用到的基本性质。

 

## 支配树相关性质

　　首先，我们会使用一棵DFS树来帮助我们计算。从起点出发进行DFS就可以得到一棵DFS树。

![img](https://images2015.cnblogs.com/blog/842061/201706/842061-20170604095337180-1181442595.png)

 

　　观察上面这幅图，我们可以注意到原图中的边被分为了几类。在DFS树上出现的边称作树边，剩下的边称为非树边。非树边也可以分为几类，从祖先指向后代（前向边），从后代指向祖先（后向边），从一棵子树內指向另一棵子树内（横叉边）。树边是我们非常熟悉的，所以着重考虑一下非树边。

　　我们按照DFS到的先后顺序给点从小到大编号（在下面的内容中我们通过这个比较两个节点），那么前向边总是由编号小的指向编号大的，后向边总是由大指向小，横叉边也总是由大指向小。现在在DFS树上我们要证明一些重要的引理。



------



### 半支配点定义

​	半支配点（semi-dominator），缩写为 $sdom(x)$。

​	对于 $w \neq r$，它的半支配点定义为 $sdom(w)=\min\{ v | \exists (v_0\to v_1\to \cdots\to v_{k-1}\to v_k), v_0 = v, v_k = w, \forall 1 \leq i \leq k-1, v_i>w \}$。

　　对于这个定义的理解其实就是从 $v$ 出发，绕过 $w$ 之前（即小于 $w$）的所有点到达 $w$。（只能以它之后的点作为落脚点）

　　注意这只是个辅助定义，并不是真正的最近支配点。甚至它都不一定是支配点。例子：$V = \{1,2,3,4\},\ E =  \{(1,2),(2,3),(3,4),(1,3),(2,4)\},\ r = 1,\ sdom(4) = 2$，但是 $2$ 不支配 $4$。不过它代表了有潜力成为支配点的点，在后面我们可以看到，所有的 $idom$ 都来自自己或者另一个点的 $sdom$。

 ![8](C:\Users\25394\Desktop\md\图论\picture\8.png)

 

------



### 	 约定记号

　　在继续之前，我们先约定一些记号：

　　$V$ 代表图的点集，$E$ 代表图的边集。

　　$a \to b$ 代表从点 $a$ 直接经过一条边到达点 $b$，

　　$a \leadsto b$ 代表从点 $a$ 经过某条路径到达点 $b$，

　　$a \dot \to b$ 代表从点 $a$ 经过 DFS 树上的树边到达点 $b$（$a$ 是 $b$ 在 DFS 树上的祖先），

　　$a \overset{+}{\to} b$ 代表 $a \dot \to b$ 且 $a \neq b$。

​	[$a\overset{+}{\to}b$）代表 $a\overset{+}{\to}b$ 上的所有点，包含 a 不包含 b。

​	图中用 i(x) 表示 $idom(x)$，用 s(x) 表示 $sdom(x)$。

　　

------

 

### 引理 1（路径引理） <span id="lemma1"> </span>

​	如果两个点 $v,w$ 满足 $v \leq w$，那么任意 $v$ 到 $w$ 的路径经过 $v,w$ 的公共祖先。（注意这里不是说 LCA）

**证明**

​	如果 $v,w$ 其中一个是另一个的祖先显然成立。否则删掉起点到 LCA 路径上的所有点（这些点是 $v,w$ 的公共祖先），那么 $v$ 和 $w$ 在两棵子树内，并且因为公共祖先被删去，无法通过后向边到达子树外面，前向边也无法跨越子树，而横叉边只能从大到小，所以从 $v$出发不能离开这颗子树到达 $w$。所以如果本来 $v$ 能够到达 $w$，就说明这些路径必须经过 $v,w$ 的公共祖先。

 

------



### 引理 2

​	对于任意 $w \neq r$，有 $idom(w) \overset{+}{\to} w$。

　　证明很显然，如果不是这样的话就可以直接通过树边不经过 $idom(w)$ 就到达$w$了，与 $idom$ 定义矛盾。

 

------

 

### 引理 3

​	对于任意 $w \neq r$，有 $sdom(w) \overset{+}{\to} w$。

**证明**

​	对于 $w$ 在 DFS 树上的父亲 $fa_w$，[$fa_w \to w$] 这条路径只有两个点，满足 $sdom$ 定义中的条件，是 $sdom(w)$ 的一个候选，所以 $sdom(w) \leq fa_w$。根据路径引理 $sdom(w)$ 一定是 $w$ 的祖先而不是在另一棵子树，因为如果是那样的话路径就会经过 $sdom(w)$ 和 $fa$ 的一个公共祖先，公共祖先的编号一定小于 $w$，不满足 $sdom$ 的定义。于是 $sdom(w)$ 就是 $w$ 的真祖先。

 

------

 

### 引理 4 <span id="lemma4"> </span>

​	对于任意 $w \neq  r$，有 $idom(w) \dot \to sdom(w)$。

**证明：**

​	如果不是这样的话，按照 $sdom$ 的定义，就会有一条路径是 $r \dot \to sdom(w) \leadsto w$ 不经过 $idom(w)$ 了，与 $idom$ 定义矛盾。

 

------

 

### 　　引理 5

​	对于满足 $v \dot \to w$ 的点 $v,w$，$v \dot \to idom(w)$ 或 $idom(w) \dot \to idom(v)$。

​	（也就是 $idom(w)$ 到 $w$ 的路径和 $idom(v)$ 到 $v$ 的路径相交长度为 $0$ 或者被完全包含）

**证明：**

​	如果不是这样的话，就是$idom(v) \overset{+}{\to} idom(w) \overset{+}{\to} v \overset{+}{\to} w$，那么存在路径$r \dot \to idom(v) \leadsto v \overset{+}{\to}w$不经过$idom(w)$到达了$w$（因为$idom(w)$是$idom(v)$的真后代，一定不支配$v$，所以存在绕过$idom(w)$到达$v$的路径），矛盾。

 ![9](C:\Users\25394\Desktop\md\图论\picture\9.png)

------

 

　　上面这 5 条引理都比较简单，不过是非常重要的性质。接下来我们要证明几个定理，它们揭示了 $idom$ 与 $sdom$ 的关系。证明可能会比上面的复杂一点。



------

 

### 　　定理 2

​	对于任意 $w \neq r$，如果所有满足 $sdom(w) \overset{+}{\to} u \overset{+}{\to} w$ 的 $u$ 也满足 $sdom(u) \geq sdom(w)$，即所有的 $u$ 满足 $$ sdom(w) \dot \to sdom(u) \overset{+}{\to} u \overset{+}{\to} w $$，那么 $idom(w) = sdom(w)$。

**证明：**

​	由上面的 [引理 4](#lemma4) 知道 $idom(w) \dot \to sdom(w)$，所以只要证明 $sdom(w)$ 支配 $w$ 就可以保证是最近支配点了。

​	假设 $idom(w)\neq sdom(w)$，即 $idom(w)\overset{+}{\to}sdom(w)$，如图，$u$ 为 $sdom(w) \overset{+}{\to} w$ 上的任意一点：

![1](C:\Users\25394\Desktop\md\图论\picture\1.png)

​	因为 $idom(w) = x$ 而非 $y$，所以存在一条 $x$ 不经过 $y$ 到 $w$ 的路径 $path$：

![2](C:\Users\25394\Desktop\md\图论\picture\2.png)

​	又因为 $x < y$ 且能到达 $w$，但 $sdom(w) = y$ 而非 $x$，所以 $path$ 还要经过一点 $t$，$t<w$ 使得 $x$ 不满足成为半支配点的条件。因为 $t<w$ 且 $t\leadsto w$，根据 [引理 1](#lemma1) 要么 $t$ 是 $w$ 的祖先，要么 $t$ 经过 $w$ 的祖先，这时取最小的那个祖先为 $u$。

![3](C:\Users\25394\Desktop\md\图论\picture\3.png)

​	同时，因为 $u$ 是最小的祖先，所以 $path$ 上的点一定 $\geq$ $u$，则 $x$ 是 $sdom(u)$ 的候选，$sdom(u) \leq x < sdom(w)$。 

​	即，当 $idom(x) \neq sdom(x)$ 时，在 $sdom(w) \dot \to w$ 上一定存在一点 $u$ 满足 $sdom(u) < sdom(w)$。

​	反之，当所有满足 $sdom(w) \overset{+}{\to} u \overset{+}{\to} w$ 的 $u$ 全都满足 $sdom(u) \geq sdom(w)$ 时，$idom(x)=sdom(x)$。



### 　　定理 3

​	对于任意 $w \neq r$​，令 $u$​ 为所有满足 $sdom(w) \overset{+}{\to} u \dot \to w$​ 的 $u$​ 中 $sdom(u)$​ 最小的一个，那么 $sdom(u) \leq sdom(w)\Rightarrow idom(w) = idom(u)$。

![4](C:\Users\25394\Desktop\md\图论\picture\4.png)

**证明：**

​	由引理5，有 $idom(w) \dot \to idom(u)$ 或 $u \dot \to idom(w)$，由 [引理 4](#lemma4) 排除后面这种。所以 $idom(w)\dot \to idom(u)$。

![5](C:\Users\25394\Desktop\md\图论\picture\5.png)

​	下面证明 $idom(w) = idom(u)$：

​		**假设：**$idom(w)\overset{+}{\to}idom(u)$。

​		因为 $idom(w) = x$ 而非 $y$，所以存在一条由 $x$ 通过 $u$ 的一些后继节点（和一些不在 $x \overset{+}{\to} u$ 路径上的点）到达 $w$ 的路径。

​		1. 后继节点中有一点 $t$ 位于 $u$ 和 $w$ 之间（不包含 $w$)，则 $x$ 是 $sdom(t)$ 的候选，$sdom(t) \leq x \leq sdom(u)$，与 $sdom(u)$ 最小矛盾。

![6](C:\Users\25394\Desktop\md\图论\picture\6.png)

​		2. 后继节点所有点都位于 $w$ 之后（包含 $w$)，则 $x$ 是 $sdom(w)$ 的候选，$sdom(w) \leq x \leq sdom(u)$，与 $sdom(u) \leq sdom(w)$ 矛盾。

![7](C:\Users\25394\Desktop\md\图论\picture\7.png)

​		因此假设不成立，所以 $idom(w) = idom(u)$。



------

 

　　幸苦地完成了上面两个定理的证明，我们就能够通过 $sdom$ 求出 $idom$ 了：



------

 

### 　　推论 1 <span id="infer1"> </span>

​	对于 $w \neq r$，令 $u$ 为所有满足 $sdom(w) \overset{+}{\to} u \dot \to w$ 的 $u$ 中 $sdom(u)$ 最小的一个，有：

　　	$$ idom(w) =  \left \{  \begin{aligned}& sdom(w)&(sdom(u)=sdom(w))&\\ &idom(u)&(sdom(u)<sdom(w))&\end{aligned} \right .$$



------

 

　　接下来我们的问题是，直接通过定义计算 $sdom$ 很低效，我们需要更加高效的方法，所以我们证明下面这个定理：



------

 

### 　　定理 4（半支配点的替代定义） <span id="theorem4"> </span>

​	对于任意 $w \neq r$，$sdom(w) = min(\{v | (v, w) \in E , v < w \} \cup \{sdom(u) | u > w , \exists (v, w) \in E , u \dot \to v\} )$

**证明：**

​	令等号右侧为 $x$，$x$ 左集合中的点显然是半支配点的候选，根据半支配点的定义 $sdom(w) \leq x$；右集合的点中 $u>w$，因为 ($u \dot \to v$] 上的点都是从 $u$ 开始的树边上的点，所有点都 $>u>w$，($sdom(u)\overset{+}{\to}u$] 中的点也都 $\geq u>w$，所以 $sdom(u)$ 也是 $w$ 半支配点的候选，所以 $x$ 中的点都是 $w$ 半支配点的候选，根据半支配点的定义 $sdom(w) \leq x$。

​	然后我们考虑 $sdom(w)$ 到 $w$ 的绕过 $w$ 之前的点的路径，如果只有一条边，那么必定满足 $(sdom(w),w) \in E$，所以 $sdom(w)$ 是 $x$ 的候选，$x \leq sdom(w)$；

​	如果多于一条边，令路径上 $w$ 的上一个点为 $v$，我们取路径上除两端外满足 $u \dot \to v$ 的最小的 $u$。因为这个 $u$ 是在树边上的点中最小的，不在树边上的点因为存在一条非树边到达在树边上的点，所以一定 $>u$，即 $sdom(w)\dot \to u$ 路径上的所有点都 $>u$，因此 $sdom(w)$ 是 $sdom(u)$ 的候选，$sdom(u) \leq sdom(w)$，同时，这个 $sdom(u)$ 满足右集合的条件（$u$ 在 $sdom(w)\overset{+}{\to}w$ 的路径上，所以 $u>w$，并且 $u\dot \to v$，$(v, w) \in E$），所以 $sdom(u)$ 是 $x$ 的候选，所以 $x \leq sdom(u) \leq sdom(w)$。

​	综上，$sdom(w) \leq x$ 且 $x \leq sdom(w)$，所以 $x=sdom(w)$。

 

------

 

　　好啦，最困难的步骤已经完成了，我们得到了 $sdom$ 的一个替代定义，而且这个定义里面的形式要简单得多。这种基本的树上操作我们是非常熟悉的，所以没有什么好担心的了。接下来就可以给出我们需要的算法了。

 

## Lengauer-Tarjan 算法

### 算法流程

　　1、初始化、跑一遍 DFS 得到 DFS 树和标号。
　　2、按标号从大到小求出 $sdom$（利用 [定理 4](#theorem4)）。
　　3、通过 [推论 1](#infer1) 求出所有能确定的 $idom$，剩下的点记录下和哪个点的 $idom$ 是相同的。
　　4、按照标号从小到大再跑一次，得到所有点的 $idom$。

　　很简单对不对~有了理论基础后算法就很显然了。

 

### 具体实现

Lengauer-Tarjan 算法的分为三步：

1. 求出 dfs 树，得到每个点 $𝑘$ 的 dfs 序 $dfn[k]$。
2. 求解半支配点。
3. 求解支配点。

#### 求解半支配点

​	根据半支配点的替代定义，求一个点 $w$ 的半支配点需要遍历它的所有前驱($<w$)，或前驱的所有祖先($>w$)，后半部分通过暴力求解显然复杂度爆炸，所以我们需要使用一个巧妙的方式：

​	考虑**倒序遍历 $dfn$**，则在遍历点 $w$ 之前，所有通过绕路到达 $w$ 的点都会在 $w$ 之前被遍历，也就是我们替换定义中 $w$ 前驱的所有祖先都会在 $w$ 之前被遍历，我们只需求出它们之中最小的 $sdom$ 就好。

​	使用加权并查集就可以维护我们需要的最小 $sdom$，并查集权值 $sdom_{min}$ 存的便是一个点的祖先们的 $sdom$ 的最小值。在求出一个点 $w$ 的半支配点后，在并查集中连接 $w$ 和它树上的父亲 $fa[w]$，然后更新权值即可。

​	如图，加粗边是树边，在遍历点 4 之前，5、6 两点一定会先被遍历并维护 $sdom_{min}$，然后再是遍历点 4、3、2，最后才遍历到点 1 和它之前的点：

![10](C:\Users\25394\Desktop\md\图论\picture\10.png)



#### 求解支配点

当求完 $sdom(x)$ 并将要把 $x$ 和 $fa[x]$ 在并查集上合并之前，



 

### 代码实现

 



## 欢快的彩蛋 卡并查集！

　　是不是听到周围有人说：“我的并查集只写了路径压缩，它是单次操作$\alpha$的”。这时你要坚定你的信念，你要相信这是$O(\log n)$的。如果他告诉你这个卡不了的话…你或许会觉得确实很难卡…我也觉得很难卡…但是Tarjan总知道怎么卡。

　　现在确认一下纯路径压缩并查集的实现方法：每次基本操作$find(v)$后都把$v$到根路径上的所有点直接接在根的下面，每次合并操作对需要合并的两个点执行$find$找到它们的根。

　　看起来挺优的。（其实真的挺优的，只是没有$\alpha$那么优）

　　Tarjan的卡法基于一种特殊定义的二项树（和一般的二项树的定义不同）。

　　定义这种特殊的二项树$T_k$为一类多叉树，其中$T_1,T_2,\cdots,T_j$都是一个单独的点，对于$T_k, k>j$，$T_k$就是$T_{k-1}$再接上一个$T_{k-j}$作为它的儿子。

　　![img](https://images2015.cnblogs.com/blog/842061/201702/842061-20170227175641970-1262723806.png)

　　就像这样。这种定义有一个有趣的特性，如果我们把它继续展开，可以得到各种有趣的结果。比如我们把上面图中的$T_{k-j}$继续展开，就会变成$T_{k-j-1}$接着$T_{k-2j}$，以此类推可以展开出一串。而如果对$T_{k-1}$继续展开，父节点就会变成$T_{k-2}$，子节点多出一个$T_{k-j-1}$，以此类推可以展开成一层树。下面的图展示了展开$T_k$的不同方式。

　　![img](https://images2015.cnblogs.com/blog/842061/201702/842061-20170227184644204-839630443.png)

　　让我们好好考虑一下这意味着什么。从图4到图5…除了这些树的编号没有对应上以外，会不会有一种感觉，图5像是图4路径压缩后的结果。

　　图4的展开方式中编号的间隔都是$j$，图5的展开方式中间隔都是$1$…那么如果我们用图5的方式展开出$j$棵子树，再按图4展开会怎么样呢？（假设$j$整除$k$）

　　![img](https://images2015.cnblogs.com/blog/842061/201702/842061-20170227190124501-248530967.png)

　　变成了这个样子，就确实和路径压缩扯上关系了。如果在最顶上再加一个点，然后$j$次访问底层的$T_1,T_2,\cdots,T_j$，就可以把树压成图5的样子了，不过会多一个单点的儿子出来，因为图6中其实有两个$T_j$（因为图4展开到最后一层没有了$-1$，所以会和上一层出现一次重复）。这么一来，我们又可以做一次这一系列操作了，非常神奇！（原论文里把这个叫做self-reproduction）至于$T_k$的实际点数，通过归纳法可以得到点数不超过$(j+1)^{\frac{k}{j}-1}$。（我们只对能被$j$整除的$k$进行计算，每次$j$次展开父节点进行归纳）

　　有了这个我们就有信心卡纯路径压缩并查集了。令$m$代表询问操作数，$n$代表合并操作数，不妨设$m \geq n$，我们取$j=\left \lfloor \frac{m}{n} \right \rfloor, i=\left \lfloor \log_{j+1}\frac{n}{2} \right \rfloor +1, k = ij$。那么$T_k$的大小不超过$(j+1)^{i-1}$即$\frac{n}{2}$。接下来我们做$\frac{n}{2}$组操作，每组在最顶上加入一个点，然后对底层的$j$个节点逐一查询，每次查询的路径长度都是$i+1$。同时总共的查询次数还是不超过$m$。于是总共的复杂度是$\frac{n}{2}j(i+1)=\Omega(m \log_{1+m/n} n)$。

　　Boom~爆炸了，所以它确实是$\log$级的。

　　彩蛋到这里就结束啦…如果想知道更多并查集优化方法怎么卡，可以去看这一部分参考的原论文*Worst-Case Analysis of Set Union Algorithms*，里面还附带了一个表，有写各种并查集实现不带按秩合并和带按秩合并的复杂度，嗯，卡并查集还是挺有趣的（只是一般人想不到呀…Tarjan太强辣）…

 

　　（题外话：这次我画了好多图，感觉自己好良心呀w 其实都是对着论文上的例子画的）